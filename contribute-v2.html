<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reparations ‚àà ‚Ñù</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.95em;
        }

        /* Main layout */
        .main-container {
            display: flex;
            flex: 1;
            max-height: calc(100vh - 100px);
        }

        /* Chat panel */
        .chat-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #333;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #16213e;
        }

        .message {
            margin-bottom: 20px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.system {
            background: #1a1a2e;
            border-left: 4px solid #667eea;
            padding: 15px;
            border-radius: 0 8px 8px 0;
        }

        .message.user {
            background: #0f3460;
            border-left: 4px solid #e94560;
            padding: 15px;
            border-radius: 0 8px 8px 0;
            margin-left: 40px;
        }

        .message.assistant {
            background: #1a1a2e;
            border-left: 4px solid #00d9ff;
            padding: 15px;
            border-radius: 0 8px 8px 0;
        }

        .message-header {
            font-size: 0.8em;
            opacity: 0.7;
            margin-bottom: 8px;
        }

        .message-content {
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .message-content strong {
            color: #00d9ff;
        }

        .message-content code {
            background: #0f3460;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }

        /* Input area */
        .chat-input-area {
            padding: 20px;
            background: #1a1a2e;
            border-top: 1px solid #333;
        }

        .url-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .url-input-group input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #333;
            border-radius: 8px;
            background: #16213e;
            color: #eee;
            font-size: 14px;
        }

        .url-input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .url-input-group button {
            padding: 12px 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .url-input-group button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .url-input-group button:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
        }

        .chat-input-group {
            display: flex;
            gap: 10px;
        }

        .chat-input-group textarea {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #333;
            border-radius: 8px;
            background: #16213e;
            color: #eee;
            font-size: 14px;
            resize: none;
            min-height: 60px;
            font-family: inherit;
        }

        .chat-input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .chat-input-group button {
            padding: 12px 25px;
            background: #00d9ff;
            border: none;
            border-radius: 8px;
            color: #1a1a2e;
            font-weight: 600;
            cursor: pointer;
            align-self: flex-end;
        }

        .chat-input-group button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
        }

        /* Quick response buttons */
        .quick-responses {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
        }

        .quick-response {
            padding: 8px 15px;
            background: #0f3460;
            border: 1px solid #333;
            border-radius: 20px;
            color: #eee;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }

        .quick-response:hover {
            background: #667eea;
            border-color: #667eea;
        }

        /* Questions panel */
        .questions-panel {
            padding: 15px;
            background: #0f3460;
            border-radius: 8px;
            margin-top: 15px;
        }

        .questions-panel h4 {
            margin-bottom: 12px;
            color: #00d9ff;
        }

        .question-group {
            margin-bottom: 15px;
        }

        .question-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .question-options {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .question-option {
            padding: 8px 15px;
            background: #16213e;
            border: 2px solid #333;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .question-option:hover {
            border-color: #667eea;
        }

        .question-option.selected {
            background: #667eea;
            border-color: #667eea;
        }

        /* Side panel */
        .side-panel {
            width: 350px;
            background: #16213e;
            overflow-y: auto;
            padding: 20px;
        }

        .panel-section {
            margin-bottom: 25px;
        }

        .panel-section h3 {
            font-size: 1em;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
            color: #00d9ff;
        }

        /* Progress indicator */
        .progress-steps {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .progress-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            border-radius: 8px;
            background: #1a1a2e;
            opacity: 0.5;
        }

        .progress-step.active {
            opacity: 1;
            background: #0f3460;
            border-left: 3px solid #00d9ff;
        }

        .progress-step.completed {
            opacity: 1;
        }

        .progress-step .step-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
        }

        .progress-step.completed .step-icon {
            background: #38a169;
        }

        .progress-step.active .step-icon {
            background: #00d9ff;
            color: #1a1a2e;
        }

        /* Source info */
        .source-info {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
        }

        .source-info .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .source-info .info-label {
            opacity: 0.7;
        }

        .source-info .info-value {
            color: #00d9ff;
            text-align: right;
            max-width: 60%;
            word-break: break-all;
        }

        /* Extraction options */
        .extraction-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .extraction-option {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .extraction-option:hover {
            border-color: #667eea;
        }

        .extraction-option.recommended {
            border-color: #38a169;
        }

        .extraction-option.recommended::before {
            content: 'Recommended';
            display: inline-block;
            background: #38a169;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            margin-bottom: 8px;
        }

        .extraction-option h4 {
            margin-bottom: 5px;
        }

        .extraction-option p {
            font-size: 0.85em;
            opacity: 0.8;
        }

        /* Column structure display */
        .column-structure {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
        }

        .column-structure table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }

        .column-structure th,
        .column-structure td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        .column-structure th {
            color: #00d9ff;
        }

        /* Loading spinner */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #333;
            border-top-color: #00d9ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 900px) {
            .main-container {
                flex-direction: column;
            }

            .side-panel {
                width: 100%;
                max-height: 300px;
                order: -1;
            }

            .chat-panel {
                border-right: none;
                border-top: 1px solid #333;
            }
        }

        /* Back link */
        .back-link {
            display: inline-block;
            margin-top: 10px;
            color: rgba(255,255,255,0.7);
            text-decoration: none;
        }

        .back-link:hover {
            color: white;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Guided Research Contribution</h1>
        <p>I'll help you extract data from historical documents - just describe what you see</p>
        <a href="contribute.html" class="back-link">&larr; Back to simple submission</a>
    </div>

    <div class="main-container">
        <div class="chat-panel">
            <div class="chat-messages" id="chatMessages">
                <div class="message system">
                    <div class="message-header">System</div>
                    <div class="message-content">Welcome! Paste a URL to a historical document and I'll guide you through extracting the data.

I work best with:
- Scanned census records
- Slave schedules and petitions
- Estate inventories and wills
- Any document listing enslaved people and their owners

<strong>Paste a URL to get started.</strong></div>
                </div>
            </div>

            <div class="chat-input-area">
                <div class="url-input-group" id="urlInputGroup">
                    <input type="url" id="urlInput" placeholder="Paste URL here (e.g., https://msa.maryland.gov/...)" />
                    <button id="startBtn" onclick="startSession()">Analyze</button>
                </div>

                <div class="chat-input-group" id="chatInputGroup" style="display: none;">
                    <textarea id="chatInput" placeholder="Describe what you see, or answer my questions..." onkeydown="handleKeyDown(event)"></textarea>
                    <button id="sendBtn" onclick="sendMessage()">Send</button>
                </div>

                <div class="quick-responses" id="quickResponses"></div>

                <div class="questions-panel" id="questionsPanel" style="display: none;">
                    <h4>Quick Questions</h4>
                    <div id="questionsList"></div>
                    <button onclick="submitAnswers()" style="margin-top: 15px; padding: 10px 20px; background: #667eea; border: none; border-radius: 8px; color: white; cursor: pointer;">Submit Answers</button>
                </div>
            </div>
        </div>

        <div class="side-panel">
            <div class="panel-section">
                <h3>Progress</h3>
                <div class="progress-steps" id="progressSteps">
                    <div class="progress-step active" data-stage="url_analysis">
                        <div class="step-icon">1</div>
                        <span>Analyze URL</span>
                    </div>
                    <div class="progress-step" data-stage="content_description">
                        <div class="step-icon">2</div>
                        <span>Describe Content</span>
                    </div>
                    <div class="progress-step" data-stage="structure_confirmation">
                        <div class="step-icon">3</div>
                        <span>Confirm Structure</span>
                    </div>
                    <div class="progress-step" data-stage="extraction_strategy">
                        <div class="step-icon">4</div>
                        <span>Choose Method</span>
                    </div>
                    <div class="progress-step" data-stage="extraction_in_progress">
                        <div class="step-icon">5</div>
                        <span>Extract Data</span>
                    </div>
                    <div class="progress-step" data-stage="human_review">
                        <div class="step-icon">6</div>
                        <span>Review & Correct</span>
                    </div>
                    <div class="progress-step" data-stage="complete">
                        <div class="step-icon">7</div>
                        <span>Complete</span>
                    </div>
                </div>
            </div>

            <div class="panel-section" id="sourceInfoSection" style="display: none;">
                <h3>Source Information</h3>
                <div class="source-info" id="sourceInfo"></div>
            </div>

            <div class="panel-section" id="columnStructureSection" style="display: none;">
                <h3>Detected Structure</h3>
                <div class="column-structure" id="columnStructure"></div>
            </div>

        <div class="panel-section" id="extractionOptionsSection" style="display: none;">
            <h3>Extraction Method</h3>
            <div class="extraction-options" id="extractionOptions"></div>
        </div>

        <div class="panel-section" id="extractionResultsSection" style="display: none;">
            <h3>Extraction Results</h3>
            <div id="extractionResults"></div>
        </div>

        <div class="panel-section" id="alternativeMethodsSection" style="display: none;">
            <h3>Alternative Methods</h3>
            <div id="alternativeMethods">
                <div class="alternative-method" onclick="showTextCopyInterface()">
                    <h4>üìù Text Copy Method</h4>
                    <p>Copy and paste text manually</p>
                </div>
                <div class="alternative-method" onclick="showScreenshotUpload()">
                    <h4>üì∏ Screenshot Upload</h4>
                    <p>Upload screenshots of the document</p>
                </div>
            </div>
        </div>

        <div class="panel-section" id="debugPanelSection">
            <h3>Extraction Debug <span id="debugToggle" onclick="toggleDebugPanel()" style="cursor:pointer; float:right; font-size:0.8em;">‚ñº</span></h3>
            <div id="debugPanel" style="display: none;">
                <div id="extractionStatus" style="margin-bottom: 10px;">
                    <div class="info-row">
                        <span class="info-label">Status</span>
                        <span class="info-value" id="debugStatus">--</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Progress</span>
                        <span class="info-value" id="debugProgress">--</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Message</span>
                        <span class="info-value" id="debugMessage">--</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Elapsed</span>
                        <span class="info-value" id="debugElapsed">--</span>
                    </div>
                </div>
                <div id="debugLogContainer" style="max-height: 300px; overflow-y: auto; background: #0a0a1a; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 0.75em;">
                    <div id="debugLogEntries">No debug logs yet...</div>
                </div>
                <div style="margin-top: 10px;">
                    <button onclick="fetchDebugLog()" style="padding: 5px 10px; background: #0f3460; border: 1px solid #333; border-radius: 5px; color: #eee; cursor: pointer; font-size: 0.8em;">
                        Refresh Debug Log
                    </button>
                    <button onclick="checkCapabilities()" style="padding: 5px 10px; background: #0f3460; border: 1px solid #333; border-radius: 5px; color: #eee; cursor: pointer; font-size: 0.8em; margin-left: 5px;">
                        Check Capabilities
                    </button>
                </div>
                <div id="capabilitiesDisplay" style="margin-top: 10px; font-size: 0.8em; display: none;"></div>
            </div>
        </div>
        </div>
    </div>

    <script>
        // API configuration
        const API_BASE = window.location.hostname === 'localhost'
            ? 'http://localhost:3000'
            : 'https://reparations-platform.onrender.com';

        // Session state
        let sessionId = null;
        let currentStage = 'url_analysis';
        let pendingQuestions = [];
        let selectedAnswers = {};

        // Start a new session
        async function startSession() {
            const url = document.getElementById('urlInput').value.trim();
            if (!url) {
                alert('Please enter a URL');
                return;
            }

            // Disable button and show loading
            const btn = document.getElementById('startBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="loading"></span>';

            try {
                const response = await fetch(`${API_BASE}/api/contribute/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });

                const data = await response.json();

                if (data.success) {
                    sessionId = data.sessionId;
                    currentStage = data.stage;

                    // Add assistant message
                    addMessage('assistant', data.message);

                    // Update UI
                    updateProgress(data.stage);
                    showSourceInfo(data.analysis);

                    // Show questions if any
                    if (data.questions && data.questions.length > 0) {
                        showQuestions(data.questions);
                    }

                    // Switch to chat input
                    document.getElementById('urlInputGroup').style.display = 'none';
                    document.getElementById('chatInputGroup').style.display = 'flex';

                } else {
                    addMessage('system', `Error: ${data.error}`);
                }

            } catch (error) {
                addMessage('system', `Connection error: ${error.message}`);
            } finally {
                btn.disabled = false;
                btn.textContent = 'Analyze';
            }
        }

        // Send chat message
        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (!message || !sessionId) return;

            // Add user message
            addMessage('user', message);
            input.value = '';

            // Disable send button
            const btn = document.getElementById('sendBtn');
            btn.disabled = true;

            try {
                const response = await fetch(`${API_BASE}/api/contribute/${sessionId}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message })
                });

                const data = await response.json();

                if (data.success) {
                    // Add assistant response
                    if (data.message) {
                        addMessage('assistant', data.message);
                    }

                    // Update stage
                    if (data.stage) {
                        currentStage = data.stage;
                        updateProgress(data.stage);
                    }

                    // Show questions if any
                    if (data.questions && data.questions.length > 0) {
                        showQuestions(data.questions);
                    } else {
                        hideQuestions();
                    }

                    // Show extraction options if available
                    if (data.extractionOptions) {
                        showExtractionOptions(data.extractionOptions);
                    }

                    // Update column structure if available
                    if (data.session?.contentStructure?.columns) {
                        showColumnStructure(data.session.contentStructure.columns);
                    }

                } else {
                    addMessage('system', `Error: ${data.error}`);
                }

            } catch (error) {
                addMessage('system', `Connection error: ${error.message}`);
            } finally {
                btn.disabled = false;
            }
        }

        // Submit answers to structured questions
        async function submitAnswers() {
            if (Object.keys(selectedAnswers).length === 0) {
                alert('Please answer at least one question');
                return;
            }

            // Build description from answers
            let description = '';
            for (const [questionId, answer] of Object.entries(selectedAnswers)) {
                description += `${questionId}: ${answer}. `;
            }

            // Add user message showing their selections
            addMessage('user', `My answers:\n${Object.entries(selectedAnswers).map(([k, v]) => `- ${k}: ${v}`).join('\n')}`);

            try {
                const response = await fetch(`${API_BASE}/api/contribute/${sessionId}/describe`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ answers: selectedAnswers })
                });

                const data = await response.json();

                if (data.success) {
                    addMessage('assistant', data.message);

                    if (data.stage) {
                        currentStage = data.stage;
                        updateProgress(data.stage);
                    }

                    if (data.questions && data.questions.length > 0) {
                        showQuestions(data.questions);
                    } else {
                        hideQuestions();
                    }

                    // Clear answers for next round
                    selectedAnswers = {};
                }

            } catch (error) {
                addMessage('system', `Error: ${error.message}`);
            }
        }

        // Select extraction method
        async function selectExtractionMethod(method) {
            // Get page selection options if available
            const pageOptions = getPageSelectionOptions();
            const hasPageOptions = Object.keys(pageOptions).length > 0;

            let displayMethod = method;
            if (hasPageOptions) {
                if (pageOptions.pages) {
                    displayMethod += ` (pages: ${pageOptions.pages.join(', ')})`;
                } else if (pageOptions.startPage) {
                    displayMethod += ` (pages ${pageOptions.startPage}${pageOptions.endPage ? '-' + pageOptions.endPage : '+'})`;
                }
            }

            addMessage('user', `I'll use: ${displayMethod}`);

            try {
                const response = await fetch(`${API_BASE}/api/contribute/${sessionId}/extract`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        method,
                        options: hasPageOptions ? pageOptions : undefined
                    })
                });

                const data = await response.json();

                if (data.success) {
                    addMessage('assistant', data.message);
                    updateProgress(data.stage);

                    // Start polling for extraction status if auto_ocr
                    if (method === 'auto_ocr' && data.extractionId) {
                        pollExtractionStatus(data.extractionId);
                    }
                }

            } catch (error) {
                addMessage('system', `Error: ${error.message}`);
            }
        }

        // Current extraction ID for debug panel
        let currentExtractionId = null;
        let pollIntervalId = null;

        // Toggle debug panel visibility
        function toggleDebugPanel() {
            const panel = document.getElementById('debugPanel');
            const toggle = document.getElementById('debugToggle');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                toggle.textContent = '‚ñ≤';
            } else {
                panel.style.display = 'none';
                toggle.textContent = '‚ñº';
            }
        }

        // Format elapsed time
        function formatElapsed(ms) {
            if (ms < 1000) return `${ms}ms`;
            if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
            return `${Math.floor(ms / 60000)}m ${Math.floor((ms % 60000) / 1000)}s`;
        }

        // Update debug panel with extraction status
        function updateDebugPanel(extraction) {
            document.getElementById('debugStatus').textContent = extraction.status || '--';
            document.getElementById('debugProgress').textContent = `${extraction.progress || 0}%`;
            document.getElementById('debugMessage').textContent = extraction.statusMessage || extraction.error || '--';
            document.getElementById('debugElapsed').textContent = formatElapsed(extraction.elapsedMs || 0);

            // Color-code status
            const statusEl = document.getElementById('debugStatus');
            if (extraction.status === 'completed') {
                statusEl.style.color = '#38a169';
            } else if (extraction.status === 'failed') {
                statusEl.style.color = '#e94560';
            } else if (extraction.status === 'processing') {
                statusEl.style.color = '#00d9ff';
            } else {
                statusEl.style.color = '#eee';
            }

            // Update debug log entries if available
            if (extraction.debugLog && Array.isArray(extraction.debugLog)) {
                renderDebugLog(extraction.debugLog);
            }
        }

        // Render debug log entries
        function renderDebugLog(logs) {
            const container = document.getElementById('debugLogEntries');
            if (!logs || logs.length === 0) {
                container.innerHTML = 'No debug logs yet...';
                return;
            }

            const html = logs.map(entry => {
                const time = entry.timestamp ? new Date(entry.timestamp).toLocaleTimeString() : '--';
                const elapsed = entry.elapsed ? `+${formatElapsed(entry.elapsed)}` : '';
                const stage = entry.stage || 'UNKNOWN';
                const message = entry.message || '';
                const data = entry.data ? JSON.stringify(entry.data, null, 2) : '';

                // Color code by stage type
                let color = '#aaa';
                if (stage.includes('ERROR') || stage.includes('FAIL')) color = '#e94560';
                else if (stage.includes('COMPLETE') || stage.includes('SUCCESS')) color = '#38a169';
                else if (stage.includes('START') || stage.includes('INIT')) color = '#00d9ff';
                else if (stage.includes('DOWNLOAD')) color = '#667eea';
                else if (stage.includes('OCR')) color = '#f6ad55';

                return `<div style="margin-bottom: 8px; border-left: 2px solid ${color}; padding-left: 8px;">
                    <div style="color: ${color}; font-weight: bold;">[${time}] ${stage} ${elapsed}</div>
                    <div style="color: #ddd;">${message}</div>
                    ${data ? `<pre style="color: #888; font-size: 0.9em; margin: 4px 0; white-space: pre-wrap; word-break: break-all;">${data}</pre>` : ''}
                </div>`;
            }).join('');

            container.innerHTML = html;

            // Auto-scroll to bottom
            const logContainer = document.getElementById('debugLogContainer');
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // Fetch debug log manually
        async function fetchDebugLog() {
            if (!sessionId || !currentExtractionId) {
                alert('No active extraction to debug');
                return;
            }

            try {
                const response = await fetch(
                    `${API_BASE}/api/contribute/${sessionId}/extraction/${currentExtractionId}/status?debug=true`
                );
                const data = await response.json();

                if (data.success) {
                    updateDebugPanel(data.extraction);

                    // Show the debug panel if hidden
                    document.getElementById('debugPanel').style.display = 'block';
                    document.getElementById('debugToggle').textContent = '‚ñ≤';
                } else {
                    alert(`Failed to fetch debug log: ${data.error}`);
                }
            } catch (error) {
                alert(`Error fetching debug log: ${error.message}`);
            }
        }

        // Check system capabilities
        async function checkCapabilities() {
            try {
                const response = await fetch(`${API_BASE}/api/contribute/capabilities`);
                const data = await response.json();

                const display = document.getElementById('capabilitiesDisplay');
                display.style.display = 'block';

                if (data.success) {
                    const caps = data.capabilities;
                    display.innerHTML = `
                        <div style="background: #0a0a1a; padding: 10px; border-radius: 5px;">
                            <div style="margin-bottom: 5px; font-weight: bold;">System Capabilities:</div>
                            <div>OCR Processor: ${caps.ocrProcessor ? '‚úÖ' : '‚ùå'}</div>
                            <div>Google Vision: ${caps.googleVision ? '‚úÖ' : '‚ùå'}</div>
                            <div>Tesseract: ${caps.tesseract ? '‚úÖ' : '‚ùå'}</div>
                            <div>Puppeteer: ${caps.puppeteer ? '‚úÖ' : '‚ùå'}</div>
                            <div>Playwright: ${caps.playwright ? '‚úÖ' : '‚ùå'}</div>
                            <div style="margin-top: 5px; color: ${caps.browserAutomation ? '#38a169' : '#e94560'};">
                                ${data.message}
                            </div>
                        </div>
                    `;
                } else {
                    display.innerHTML = `<div style="color: #e94560;">Failed to check capabilities: ${data.error}</div>`;
                }
            } catch (error) {
                document.getElementById('capabilitiesDisplay').innerHTML =
                    `<div style="color: #e94560;">Error: ${error.message}</div>`;
            }
        }

        // Poll extraction status with enhanced debugging
        async function pollExtractionStatus(extractionId) {
            currentExtractionId = extractionId;

            // Show debug panel automatically when extraction starts
            document.getElementById('debugPanel').style.display = 'block';
            document.getElementById('debugToggle').textContent = '‚ñ≤';

            // Clear any existing poll interval
            if (pollIntervalId) {
                clearInterval(pollIntervalId);
            }

            let pollCount = 0;
            const maxPolls = 300; // 10 minutes at 2-second intervals

            pollIntervalId = setInterval(async () => {
                pollCount++;

                try {
                    // Fetch with debug info every 5 polls, otherwise basic status
                    const includeDebug = pollCount % 5 === 0 || pollCount <= 3;
                    const response = await fetch(
                        `${API_BASE}/api/contribute/${sessionId}/extraction/${extractionId}/status?debug=${includeDebug}`
                    );
                    const data = await response.json();

                    if (data.success) {
                        const extraction = data.extraction;

                        // Always update debug panel
                        updateDebugPanel(extraction);

                        if (extraction.status === 'completed') {
                            clearInterval(pollIntervalId);
                            pollIntervalId = null;

                            addMessage('assistant', `Extraction complete! Found ${extraction.rowCount} rows with ${(extraction.avgConfidence * 100).toFixed(0)}% average confidence.`);

                            // Display parsed rows if available
                            if (extraction.parsedRows && extraction.parsedRows.length > 0) {
                                displayParsedRows(extraction.parsedRows);
                            }

                            // Show alternative methods if no rows found
                            if (extraction.rowCount === 0) {
                                addMessage('system', 'No data could be extracted automatically. Please try an alternative method below.');
                                showAlternativeMethods();
                            }

                            updateProgress('human_review');

                        } else if (extraction.status === 'failed') {
                            clearInterval(pollIntervalId);
                            pollIntervalId = null;

                            addMessage('system', `Extraction failed: ${extraction.error || 'Unknown error'}`);
                            addMessage('system', 'Check the debug panel for details, or try an alternative method.');

                            // Show alternative methods
                            showAlternativeMethods();

                        } else {
                            // Show progress update in chat periodically
                            if (pollCount % 10 === 0) {
                                console.log(`Extraction progress: ${extraction.progress}% - ${extraction.statusMessage || 'Processing...'}`);
                            }
                        }
                    } else {
                        console.error('Poll returned error:', data.error);
                    }

                } catch (error) {
                    console.error('Poll error:', error);

                    // After 3 consecutive errors, stop polling
                    if (pollCount > 3) {
                        clearInterval(pollIntervalId);
                        pollIntervalId = null;
                        addMessage('system', `Lost connection to extraction process. Error: ${error.message}`);
                    }
                }

                // Stop polling after max polls
                if (pollCount >= maxPolls) {
                    clearInterval(pollIntervalId);
                    pollIntervalId = null;
                    addMessage('system', 'Extraction timed out after 10 minutes. Please try again or use an alternative method.');
                    showAlternativeMethods();
                }

            }, 2000);
        }

        // Display parsed rows in a table format
        function displayParsedRows(rows) {
            const section = document.getElementById('extractionResultsSection');
            if (!section) {
                // Create results section if it doesn't exist
                const resultsSection = document.createElement('div');
                resultsSection.id = 'extractionResultsSection';
                resultsSection.className = 'panel-section';
                resultsSection.innerHTML = `
                    <h3>Extraction Results</h3>
                    <div id="extractionResults"></div>
                `;
                document.querySelector('.side-panel').appendChild(resultsSection);
            }

            const container = document.getElementById('extractionResults');
            if (!container) return;

            // Create table header
            let html = '<table class="extraction-results-table"><thead><tr><th>Row</th>';

            // Get all unique column headers
            const headers = new Set();
            rows.forEach(row => {
                if (row.columns) {
                    Object.keys(row.columns).forEach(header => {
                        headers.add(header);
                    });
                }
            });

            // Add headers to table
            headers.forEach(header => {
                html += `<th>${header}</th>`;
            });
            html += '<th>Confidence</th></tr></thead><tbody>';

            // Add rows
            rows.forEach((row, index) => {
                html += `<tr><td>${index + 1}</td>`;
                headers.forEach(header => {
                    const value = row.columns?.[header] || '';
                    html += `<td>${value}</td>`;
                });
                html += `<td>${(row.confidence * 100).toFixed(0)}%</td></tr>`;
            });

            html += '</tbody></table>';

            // Add correction interface
            html += `
                <div style="margin-top: 15px; padding: 10px; background: #1a1a2e; border-radius: 5px;">
                    <button onclick="showCorrectionInterface()" style="padding: 8px 15px; background: #667eea; border: none; border-radius: 5px; color: white; cursor: pointer;">
                        Correct Mistakes
                    </button>
                    <div id="correctionInterface" style="display: none; margin-top: 10px;"></div>
                </div>
            `;

            container.innerHTML = html;
        }

        // Show correction interface
        function showCorrectionInterface() {
            const interface = document.getElementById('correctionInterface');
            if (!interface) return;

            interface.innerHTML = `
                <div style="margin-bottom: 10px; font-weight: 500;">Correct OCR Results</div>
                <div style="margin-bottom: 10px;">
                    <input type="number" id="correctionRowIndex" placeholder="Row #" style="padding: 5px; width: 60px; margin-right: 5px;">
                    <input type="text" id="correctionFieldName" placeholder="Field name" style="padding: 5px; width: 120px; margin-right: 5px;">
                    <input type="text" id="correctionNewValue" placeholder="Corrected value" style="padding: 5px; width: 150px; margin-right: 5px;">
                    <button onclick="submitCorrection()" style="padding: 5px 12px; background: #38a169; border: none; border-radius: 5px; color: white; cursor: pointer;">Submit</button>
                </div>
                <div id="correctionStatus" style="font-size: 0.85em; margin-top: 5px;"></div>
            `;
            interface.style.display = 'block';
        }

        // Submit correction
        async function submitCorrection() {
            const rowIndex = parseInt(document.getElementById('correctionRowIndex').value);
            const fieldName = document.getElementById('correctionFieldName').value.trim();
            const newValue = document.getElementById('correctionNewValue').value.trim();
            const statusDiv = document.getElementById('correctionStatus');

            if (!rowIndex || !fieldName || !newValue) {
                statusDiv.textContent = 'Please fill all fields';
                statusDiv.style.color = '#e94560';
                return;
            }

            try {
                // Get current session to find extraction ID
                const sessionResponse = await fetch(`${API_BASE}/api/contribute/${sessionId}`);
                const sessionData = await sessionResponse.json();

                if (!sessionData.success || !sessionData.session?.processingInstructions?.extractionId) {
                    throw new Error('Could not find extraction ID');
                }

                const extractionId = sessionData.session.processingInstructions.extractionId;

                // Submit correction
                const response = await fetch(
                    `${API_BASE}/api/contribute/${sessionId}/extraction/${extractionId}/correct`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            corrections: [{
                                rowIndex: rowIndex - 1, // Convert to 0-based index
                                field: fieldName,
                                originalValue: '', // Would need to fetch current value
                                correctedValue: newValue,
                                correctedBy: 'user'
                            }]
                        })
                    }
                );

                const data = await response.json();

                if (data.success) {
                    statusDiv.textContent = `Correction applied! ${data.correctionCount} changes saved.`;
                    statusDiv.style.color = '#38a169';
                } else {
                    throw new Error(data.error || 'Failed to apply correction');
                }

            } catch (error) {
                statusDiv.textContent = `Error: ${error.message}`;
                statusDiv.style.color = '#e94560';
                console.error('Correction error:', error);
            }
        }

        // Add message to chat
        function addMessage(role, content) {
            const messages = document.getElementById('chatMessages');
            const msg = document.createElement('div');
            msg.className = `message ${role}`;

            const header = document.createElement('div');
            header.className = 'message-header';
            header.textContent = role === 'user' ? 'You' : role === 'assistant' ? 'Assistant' : 'System';

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.innerHTML = formatMessage(content);

            msg.appendChild(header);
            msg.appendChild(contentDiv);
            messages.appendChild(msg);

            // Scroll to bottom
            messages.scrollTop = messages.scrollHeight;
        }

        // Format message with markdown-like syntax
        function formatMessage(text) {
            return text
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/`(.+?)`/g, '<code>$1</code>')
                .replace(/\n/g, '<br>');
        }

        // Update progress indicator
        function updateProgress(stage) {
            const steps = document.querySelectorAll('.progress-step');
            let foundActive = false;

            steps.forEach(step => {
                const stepStage = step.dataset.stage;

                if (stepStage === stage) {
                    step.classList.add('active');
                    step.classList.remove('completed');
                    foundActive = true;
                } else if (!foundActive) {
                    step.classList.remove('active');
                    step.classList.add('completed');
                    step.querySelector('.step-icon').textContent = '‚úì';
                } else {
                    step.classList.remove('active', 'completed');
                }
            });
        }

        // Show source info in side panel
        function showSourceInfo(analysis) {
            const section = document.getElementById('sourceInfoSection');
            const info = document.getElementById('sourceInfo');

            section.style.display = 'block';

            info.innerHTML = `
                <div class="info-row">
                    <span class="info-label">Domain</span>
                    <span class="info-value">${analysis.domain || 'Unknown'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Archive</span>
                    <span class="info-value">${analysis.archiveName || 'Unknown'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Source Type</span>
                    <span class="info-value">${analysis.sourceType || 'Unknown'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Content</span>
                    <span class="info-value">${analysis.contentType || 'Unknown'}</span>
                </div>
                ${analysis.documentTitle ? `
                <div class="info-row">
                    <span class="info-label">Title</span>
                    <span class="info-value">${analysis.documentTitle}</span>
                </div>
                ` : ''}
                ${analysis.pagination?.detected ? `
                <div class="info-row">
                    <span class="info-label">Page</span>
                    <span class="info-value">${analysis.pagination.currentPage || '?'} (multi-page)</span>
                </div>
                ` : ''}
            `;
        }

        // Show structured questions
        function showQuestions(questions) {
            const panel = document.getElementById('questionsPanel');
            const list = document.getElementById('questionsList');

            list.innerHTML = '';
            pendingQuestions = questions;

            questions.forEach(q => {
                const group = document.createElement('div');
                group.className = 'question-group';

                const label = document.createElement('label');
                label.textContent = q.question;
                group.appendChild(label);

                // Handle different question types
                if (q.type === 'number') {
                    // Render number input for numeric questions
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.min = '1';
                    input.max = '50';
                    input.style.cssText = 'padding: 8px 12px; background: #16213e; border: 2px solid #333; border-radius: 8px; color: #eee; font-size: 14px; width: 80px; margin-top: 8px;';
                    input.onchange = () => {
                        selectedAnswers[q.id] = input.value;
                    };
                    group.appendChild(input);
                } else if (q.type === 'text') {
                    // Render text input for free-form questions
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.style.cssText = 'padding: 8px 12px; background: #16213e; border: 2px solid #333; border-radius: 8px; color: #eee; font-size: 14px; width: 100%; margin-top: 8px;';
                    input.onchange = () => {
                        selectedAnswers[q.id] = input.value;
                    };
                    group.appendChild(input);
                } else if (q.options && Array.isArray(q.options)) {
                    // Render option buttons for multiple choice questions
                    const options = document.createElement('div');
                    options.className = 'question-options';

                    q.options.forEach(opt => {
                        const btn = document.createElement('button');
                        btn.className = 'question-option';
                        btn.textContent = opt.label;
                        btn.onclick = () => selectAnswer(q.id, opt.value, btn);
                        options.appendChild(btn);
                    });

                    group.appendChild(options);
                } else {
                    // Fallback: render as text input if question type is unknown
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.placeholder = 'Type your answer...';
                    input.style.cssText = 'padding: 8px 12px; background: #16213e; border: 2px solid #333; border-radius: 8px; color: #eee; font-size: 14px; width: 100%; margin-top: 8px;';
                    input.onchange = () => {
                        selectedAnswers[q.id] = input.value;
                    };
                    group.appendChild(input);
                }

                list.appendChild(group);
            });

            panel.style.display = 'block';
        }

        function hideQuestions() {
            document.getElementById('questionsPanel').style.display = 'none';
        }

        function selectAnswer(questionId, value, btn) {
            // Deselect siblings
            btn.parentElement.querySelectorAll('.question-option').forEach(b => {
                b.classList.remove('selected');
            });

            // Select this one
            btn.classList.add('selected');
            selectedAnswers[questionId] = value;
        }

        // Show column structure
        function showColumnStructure(columns) {
            const section = document.getElementById('columnStructureSection');
            const container = document.getElementById('columnStructure');

            section.style.display = 'block';

            let html = '<table><thead><tr><th>#</th><th>Type</th><th>Header</th></tr></thead><tbody>';
            columns.forEach(col => {
                html += `<tr>
                    <td>${col.position}</td>
                    <td>${col.dataType || 'unknown'}</td>
                    <td>${col.headerGuess || '-'}</td>
                </tr>`;
            });
            html += '</tbody></table>';

            container.innerHTML = html;
        }

        // Show extraction options
        function showExtractionOptions(options) {
            const section = document.getElementById('extractionOptionsSection');
            const container = document.getElementById('extractionOptions');

            section.style.display = 'block';

            // Add clear guidance at the top with MANUAL OPTIONS PROMINENTLY DISPLAYED
            container.innerHTML = `
                <div style="background: #0f3460; padding: 12px; border-radius: 8px; margin-bottom: 15px; font-size: 0.9em;">
                    <strong>üìã Choose an extraction method:</strong>
                    <p style="margin-top: 8px; opacity: 0.8;">Click on any method below to proceed. If automatic methods fail, use manual options.</p>
                </div>

                <!-- MANUAL OPTIONS - Always Available -->
                <div style="margin-bottom: 20px; padding: 15px; background: #1a3a5c; border-radius: 8px; border: 2px solid #00d9ff;">
                    <h4 style="color: #00d9ff; margin-bottom: 10px;">‚≠ê RECOMMENDED: Manual Methods (Always Work)</h4>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <div class="extraction-option recommended" onclick="showScreenshotUpload()" style="background: #16213e; cursor: pointer;">
                            <h4>üì∏ Screenshot Upload</h4>
                            <p>Take screenshots of the document pages and upload them</p>
                            <small style="opacity: 0.6;">Best for: Protected sites, complex layouts, ANY document</small>
                        </div>
                        <div class="extraction-option recommended" onclick="showTextCopyInterface()" style="background: #16213e; cursor: pointer;">
                            <h4>üìù Copy & Paste Text</h4>
                            <p>Copy text from the document and paste it here</p>
                            <small style="opacity: 0.6;">Best for: When you can select text in the document</small>
                        </div>
                    </div>
                </div>

                <!-- PDF PAGE SELECTION (shown for PDFs) -->
                <div id="pdfPageSelection" style="display: none; margin-bottom: 20px; padding: 15px; background: #0f3460; border-radius: 8px; border: 1px solid #667eea;">
                    <h4 style="color: #667eea; margin-bottom: 10px;">üìÑ PDF Page Selection</h4>
                    <p style="font-size: 0.9em; margin-bottom: 10px; opacity: 0.8;">
                        Multi-page PDFs often have cover pages and table of contents. Specify which pages contain the actual data.
                    </p>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                        <div>
                            <label style="font-size: 0.85em;">Start Page:</label>
                            <input type="number" id="pdfStartPage" value="3" min="1" style="width: 100%; padding: 8px; background: #16213e; border: 1px solid #333; border-radius: 4px; color: #eee;">
                        </div>
                        <div>
                            <label style="font-size: 0.85em;">End Page:</label>
                            <input type="number" id="pdfEndPage" value="" placeholder="All" min="1" style="width: 100%; padding: 8px; background: #16213e; border: 1px solid #333; border-radius: 4px; color: #eee;">
                        </div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 0.85em;">Or specific pages (comma-separated):</label>
                        <input type="text" id="pdfSpecificPages" placeholder="e.g., 3,5,7,8,9" style="width: 100%; padding: 8px; background: #16213e; border: 1px solid #333; border-radius: 4px; color: #eee;">
                    </div>
                    <div id="pdfPageInfo" style="font-size: 0.85em; color: #00d9ff;"></div>
                </div>

                <!-- AUTOMATIC OPTIONS -->
                <div style="margin-bottom: 10px;">
                    <h4 style="color: #667eea; margin-bottom: 10px;">ü§ñ Automatic Methods (May Fail for Protected Sites)</h4>
                </div>
            ` + options.map(opt => `
                <div class="extraction-option ${opt.recommended ? 'recommended' : ''}"
                     onclick="selectExtractionMethod('${opt.id}')">
                    <h4>${opt.label}</h4>
                    <p>${opt.description}</p>
                    <small style="opacity: 0.6;">Best for: ${opt.bestFor}</small>
                </div>
            `).join('');

            // Check if it's a PDF and show page selection
            checkAndShowPdfPageSelection();
        }

        // Check if current document is a PDF and show page selection options
        async function checkAndShowPdfPageSelection() {
            if (!sessionId) return;

            try {
                const response = await fetch(`${API_BASE}/api/contribute/${sessionId}/pdf-info`);
                const data = await response.json();

                if (data.success && data.pdfInfo) {
                    const pdfSection = document.getElementById('pdfPageSelection');
                    pdfSection.style.display = 'block';

                    const infoDiv = document.getElementById('pdfPageInfo');
                    if (data.pdfInfo.pageCount > 0) {
                        infoDiv.innerHTML = `
                            üìä Document has <strong>${data.pdfInfo.pageCount}</strong> pages.
                            <br>üí° Tip: Many archival PDFs have cover pages. We suggest starting from page 3.
                        `;
                        document.getElementById('pdfEndPage').placeholder = data.pdfInfo.pageCount;
                    } else if (data.pdfInfo.note) {
                        infoDiv.innerHTML = `‚ÑπÔ∏è ${data.pdfInfo.note}`;
                    }
                }
            } catch (error) {
                console.log('PDF info check failed (may not be a PDF):', error.message);
            }
        }

        // Get page selection options for extraction
        function getPageSelectionOptions() {
            const options = {};
            const specificPages = document.getElementById('pdfSpecificPages')?.value?.trim();

            if (specificPages) {
                // Parse comma-separated page numbers
                options.pages = specificPages.split(',')
                    .map(p => parseInt(p.trim()))
                    .filter(p => !isNaN(p) && p > 0);
            } else {
                const startPage = parseInt(document.getElementById('pdfStartPage')?.value);
                const endPage = parseInt(document.getElementById('pdfEndPage')?.value);

                if (startPage && !isNaN(startPage)) {
                    options.startPage = startPage;
                }
                if (endPage && !isNaN(endPage)) {
                    options.endPage = endPage;
                }
            }

            return options;
        }

        // Handle Enter key in chat input
        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        // Quick response click
        function quickResponse(text) {
            document.getElementById('chatInput').value = text;
            sendMessage();
        }

        // Show text copy interface
        function showTextCopyInterface() {
            const section = document.getElementById('alternativeMethodsSection');
            section.style.display = 'block';

            const container = document.getElementById('alternativeMethods');
            container.innerHTML = `
                <div style="background: #1a1a2e; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h4>üìù Copy & Paste Text</h4>
                    <p>Copy text directly from the document:</p>
                    <ol style="margin: 10px 0; padding-left: 20px;">
                        <li>Open the document in your browser</li>
                        <li>Select and copy the text (Ctrl+C / Cmd+C)</li>
                        <li>Paste it below (Ctrl+V / Cmd+V)</li>
                    </ol>
                    <div style="background: #0f3460; padding: 10px; border-radius: 5px; margin-bottom: 10px; font-size: 0.85em;">
                        <strong>üí° Tip:</strong> Include column headers if visible. The system will try to parse the text into rows automatically.
                    </div>
                    <textarea id="manualTextInput" placeholder="Paste document text here...

Example:
DATE        NAME OF OWNER       NAME OF SLAVE       SEX     AGE
1867 May 1  Thomas Griffith     Lydia King          Female  50
1867 May 1  Thomas Griffith     William Kall        Male    45"
                              style="width: 100%; height: 200px; padding: 10px; background: #16213e; border: 2px solid #333; border-radius: 5px; color: #eee; margin: 10px 0; resize: vertical; font-family: monospace; font-size: 0.9em;"></textarea>
                    <button onclick="processManualText()" style="padding: 10px 20px; background: #667eea; border: none; border-radius: 5px; color: white; cursor: pointer; width: 100%;">
                        üìã Process Pasted Text
                    </button>
                    <div id="textProcessingStatus" style="margin-top: 10px; font-size: 0.85em;"></div>
                </div>
                <button onclick="hideAlternativeMethods()" style="padding: 8px 15px; background: #0f3460; border: 1px solid #333; border-radius: 5px; color: #eee; cursor: pointer;">
                    ‚Üê Back
                </button>
            `;
        }

        // Hide alternative methods section
        function hideAlternativeMethods() {
            document.getElementById('alternativeMethodsSection').style.display = 'none';
        }

        // Process manual text input
        async function processManualText() {
            const text = document.getElementById('manualTextInput').value.trim();
            const statusDiv = document.getElementById('textProcessingStatus');

            if (!text) {
                statusDiv.textContent = 'Please paste some text';
                statusDiv.style.color = '#e94560';
                return;
            }

            statusDiv.innerHTML = '<span class="loading"></span> Processing text...';
            statusDiv.style.color = '#00d9ff';

            try {
                // First, ensure we have an extraction job
                let extractionId = currentExtractionId;

                if (!extractionId && sessionId) {
                    // Try to get extraction ID from session
                    const sessionResponse = await fetch(`${API_BASE}/api/contribute/${sessionId}`);
                    const sessionData = await sessionResponse.json();

                    if (sessionData.success && sessionData.session?.processingInstructions?.extractionId) {
                        extractionId = sessionData.session.processingInstructions.extractionId;
                    }
                }

                // If still no extraction ID, create one with manual_text method
                if (!extractionId && sessionId) {
                    statusDiv.innerHTML = '<span class="loading"></span> Initializing extraction job...';
                    const extractResponse = await fetch(`${API_BASE}/api/contribute/${sessionId}/extract`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ method: 'manual_text' })
                    });
                    const extractData = await extractResponse.json();
                    if (extractData.success) {
                        extractionId = extractData.extractionId;
                        currentExtractionId = extractionId;
                    } else {
                        throw new Error('Failed to create extraction job: ' + (extractData.error || 'Unknown error'));
                    }
                }

                if (!extractionId) {
                    throw new Error('No session or extraction ID available. Please start by pasting a URL.');
                }

                statusDiv.innerHTML = '<span class="loading"></span> Parsing text into rows...';

                // Submit manual text for processing
                const response = await fetch(
                    `${API_BASE}/api/contribute/${sessionId}/extraction/${extractionId}/manual-text`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            text: text,
                            method: 'manual_text'
                        })
                    }
                );

                const data = await response.json();

                if (data.success) {
                    statusDiv.innerHTML = `‚úÖ Text processed! Found <strong>${data.rowCount}</strong> rows.`;
                    statusDiv.style.color = '#38a169';

                    addMessage('assistant', `Text processing complete! Found ${data.rowCount} rows with ${(data.avgConfidence * 100).toFixed(0)}% average confidence.`);

                    // Show results
                    if (data.parsedRows && data.parsedRows.length > 0) {
                        displayParsedRows(data.parsedRows);
                    }

                    updateProgress('human_review');
                } else {
                    throw new Error(data.error || 'Failed to process text');
                }

            } catch (error) {
                statusDiv.innerHTML = `‚ùå Error: ${error.message}`;
                statusDiv.style.color = '#e94560';
                console.error('Manual text processing error:', error);
                addMessage('system', `Text processing failed: ${error.message}`);
            }
        }

        // Show screenshot upload interface
        function showScreenshotUpload() {
            const section = document.getElementById('alternativeMethodsSection');
            section.style.display = 'block';

            const container = document.getElementById('alternativeMethods');
            container.innerHTML = `
                <div style="background: #1a1a2e; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h4>üì∏ Screenshot Upload</h4>
                    <p>Upload screenshots of the document pages:</p>
                    <ol style="margin: 10px 0; padding-left: 20px;">
                        <li>Open the document in your browser</li>
                        <li>Take a screenshot (Cmd+Shift+4 on Mac, Win+Shift+S on Windows)</li>
                        <li>Upload the image(s) below</li>
                    </ol>
                    <div style="background: #0f3460; padding: 10px; border-radius: 5px; margin-bottom: 10px; font-size: 0.85em;">
                        <strong>üí° Tip:</strong> For best results, zoom in so text is clearly visible. You can upload multiple images for multi-page documents.
                    </div>
                    <input type="file" id="screenshotUpload" accept="image/*" multiple
                           style="margin: 10px 0; display: block; padding: 10px; background: #16213e; border: 2px dashed #333; border-radius: 5px; width: 100%; cursor: pointer;">
                    <div id="screenshotPreview" style="display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0;"></div>
                    <button onclick="uploadScreenshots()" style="padding: 10px 20px; background: #667eea; border: none; border-radius: 5px; color: white; cursor: pointer; width: 100%;">
                        üì§ Upload & Process Images
                    </button>
                    <div id="screenshotUploadStatus" style="margin-top: 10px; font-size: 0.85em;"></div>
                </div>
                <button onclick="hideAlternativeMethods()" style="padding: 8px 15px; background: #0f3460; border: 1px solid #333; border-radius: 5px; color: #eee; cursor: pointer;">
                    ‚Üê Back
                </button>
            `;

            // Add file preview handler
            document.getElementById('screenshotUpload').onchange = function(e) {
                const preview = document.getElementById('screenshotPreview');
                preview.innerHTML = '';
                for (const file of e.target.files) {
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(file);
                    img.style.cssText = 'max-width: 100px; max-height: 100px; border-radius: 5px; border: 1px solid #333;';
                    preview.appendChild(img);
                }
            };
        }

        // Upload and process screenshots
        async function uploadScreenshots() {
            const input = document.getElementById('screenshotUpload');
            const files = input.files;
            const statusDiv = document.getElementById('screenshotUploadStatus');

            if (!files || files.length === 0) {
                statusDiv.textContent = 'Please select at least one image';
                statusDiv.style.color = '#e94560';
                return;
            }

            statusDiv.innerHTML = `<span class="loading"></span> Uploading ${files.length} image(s)...`;
            statusDiv.style.color = '#00d9ff';

            try {
                // First, ensure we have an extraction job
                let extractionId = currentExtractionId;

                if (!extractionId && sessionId) {
                    // Try to get extraction ID from session
                    const sessionResponse = await fetch(`${API_BASE}/api/contribute/${sessionId}`);
                    const sessionData = await sessionResponse.json();

                    if (sessionData.success && sessionData.session?.processingInstructions?.extractionId) {
                        extractionId = sessionData.session.processingInstructions.extractionId;
                    }
                }

                // If still no extraction ID, create one with screenshot_upload method
                if (!extractionId && sessionId) {
                    statusDiv.innerHTML = `<span class="loading"></span> Initializing extraction job...`;
                    const extractResponse = await fetch(`${API_BASE}/api/contribute/${sessionId}/extract`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ method: 'screenshot_upload' })
                    });
                    const extractData = await extractResponse.json();
                    if (extractData.success) {
                        extractionId = extractData.extractionId;
                        currentExtractionId = extractionId;
                    } else {
                        throw new Error('Failed to create extraction job: ' + (extractData.error || 'Unknown error'));
                    }
                }

                if (!extractionId) {
                    throw new Error('No session or extraction ID available. Please start by pasting a URL.');
                }

                statusDiv.innerHTML = `<span class="loading"></span> Processing ${files.length} image(s) with OCR...`;

                // Create form data for file upload
                const formData = new FormData();
                for (let i = 0; i < files.length; i++) {
                    formData.append('images', files[i]);
                }

                // Upload images
                const response = await fetch(
                    `${API_BASE}/api/contribute/${sessionId}/extraction/${extractionId}/screenshots`,
                    {
                        method: 'POST',
                        body: formData
                    }
                );

                const data = await response.json();

                if (data.success) {
                    statusDiv.innerHTML = `‚úÖ Processed ${files.length} image(s)! Found <strong>${data.rowCount}</strong> rows.`;
                    statusDiv.style.color = '#38a169';

                    addMessage('assistant', `Screenshot processing complete! Found ${data.rowCount} rows with ${(data.avgConfidence * 100).toFixed(0)}% average confidence.`);

                    // Show results
                    if (data.parsedRows && data.parsedRows.length > 0) {
                        displayParsedRows(data.parsedRows);
                    }

                    updateProgress('human_review');
                } else {
                    throw new Error(data.error || 'Failed to process screenshots');
                }

            } catch (error) {
                statusDiv.innerHTML = `‚ùå Error: ${error.message}`;
                statusDiv.style.color = '#e94560';
                console.error('Screenshot upload error:', error);
                addMessage('system', `Screenshot processing failed: ${error.message}`);
            }
        }

        // Show alternative methods menu
        function showAlternativeMethods() {
            const section = document.getElementById('alternativeMethodsSection');
            section.style.display = 'block';

            const container = document.getElementById('alternativeMethods');
            container.innerHTML = `
                <div class="alternative-method" onclick="showTextCopyInterface()" style="cursor: pointer; padding: 15px; background: #1a1a2e; border-radius: 8px; margin-bottom: 10px; border: 1px solid #333;">
                    <h4 style="margin-bottom: 5px;">üìù Text Copy Method</h4>
                    <p style="font-size: 0.85em; opacity: 0.8;">Copy and paste text from the document manually</p>
                </div>
                <div class="alternative-method" onclick="showScreenshotUpload()" style="cursor: pointer; padding: 15px; background: #1a1a2e; border-radius: 8px; margin-bottom: 10px; border: 1px solid #333;">
                    <h4 style="margin-bottom: 5px;">üì∏ Screenshot Upload</h4>
                    <p style="font-size: 0.85em; opacity: 0.8;">Upload screenshots of the document pages</p>
                </div>
                <div class="alternative-method" onclick="retryWithDifferentUrl()" style="cursor: pointer; padding: 15px; background: #1a1a2e; border-radius: 8px; margin-bottom: 10px; border: 1px solid #333;">
                    <h4 style="margin-bottom: 5px;">üîÑ Try Different URL</h4>
                    <p style="font-size: 0.85em; opacity: 0.8;">Paste a direct PDF link if available</p>
                </div>
            `;
        }

        // Retry with different URL
        function retryWithDifferentUrl() {
            const newUrl = prompt('Enter a direct URL to the PDF or image file:');
            if (newUrl && newUrl.trim()) {
                // Start a new extraction with the provided URL
                addMessage('user', `Trying with URL: ${newUrl}`);
                // Could implement direct extraction here
                addMessage('system', 'This feature is coming soon. For now, please use the Text Copy or Screenshot Upload methods.');
            }
        }

        // Auto-check capabilities on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Silently check capabilities in background
            fetch(`${API_BASE}/api/contribute/capabilities`)
                .then(r => r.json())
                .then(data => {
                    if (data.success && !data.capabilities.browserAutomation) {
                        console.warn('Browser automation not available - some extraction methods may be limited');
                    }
                })
                .catch(e => console.warn('Could not check capabilities:', e));
        });
    </script>
</body>
</html>
